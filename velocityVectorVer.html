<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      body {
        margin: 0;
        width: 100%;
        height: 100vh;
      }
      canvas {
        width: 100%;
        /* background-color: #000; */
      }
    </style>
  </head>
  <body>
    <canvas id="mycanvas"> </canvas>
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"
      integrity="sha512-LF8ZB1iTwi4Qvkm4pekHG4a437Y9Af5ZuwbnW4GTbAWQeR2E4KW8WF+xH8b9psevV7wIlDMx1MH9YfPqgKhA/Q=="
      crossorigin="anonymous"
    ></script>
    <script>
      class Vector {
        constructor(x, y) {
          this.x = x;
          this.y = y;
        }

        add(v) {
          return new Vector(this.x + v.x, this.y + v.y);
        }

        move(x, y) {
          this.x += x;
          this.y += y;
          return this;
        }

        sub(v) {
          return new Vector(this.x - v.x, this.y - v.y);
        }

        toString() {
          return `(${this.x},${this.y})`;
        }

        mul(s) {
          return new Vector(this.x * s, this.y * s);
        }

        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }

        set(x, y) {
          this.x = x;
          this.y = y;
          return this;
        }

        equal(v) {
          return this.x == v.x && this.y == v.y;
        }

        clone() {
          return new Vector(this.x, this.y);
        }

        angle() {
          // 轉角度
          return Math.atan2(this.y, this.x);
        }
      }

      let canvas = document.getElementById("mycanvas");
      let ctx = canvas.getContext("2d");

      ww = canvas.width = window.innerWidth;
      wh = canvas.height = window.innerHeight;

      window.addEventListener("resize", function () {
        ww = canvas.width = window.innerWidth;
        wh = canvas.height = window.innerHeight;
      });

      // 球
      class Ball {
        constructor() {
          this.p = new Vector(ww / 2, wh / 2);
          this.v = new Vector(-10, 3);
          this.a = new Vector(0, 1);
          this.r = 50;
          this.dragging = false;
        }
        draw() {
          ctx.beginPath();
          ctx.save();
          ctx.translate(this.p.x, this.p.y);
          ctx.arc(0, 0, this.r, 0, Math.PI * 2);
          ctx.fillStyle = controls.color;
          ctx.fill();
          ctx.restore();

          this.drawV();
        }
        update() {
          if (!this.dragging) {
            this.p = this.p.add(this.v);
            this.v = this.v.add(this.a);
            this.v = this.v.mul(controls.fade);

            // new dat
            controls.vx = this.v.x;
            controls.vy = this.v.y;
            controls.ay = this.a.y;

            this.checkBoundary();
          }
        }
        checkBoundary() {
          if (this.p.x + this.r > ww) {
            this.v.x = -Math.abs(this.v.x);
          }
          if (this.p.x - this.r < 0) {
            this.v.x = Math.abs(this.v.x);
          }
          if (this.p.y + this.r > wh) {
            this.v.y = -Math.abs(this.v.y);
          }
          if (this.p.y - this.r < 0) {
            this.v.y = Math.abs(this.v.y);
          }
        }
        drawV() {
          ctx.beginPath();
          ctx.save();
          ctx.translate(this.p.x, this.p.y);
          ctx.scale(3, 3);
          ctx.moveTo(0, 0);
          ctx.lineTo(this.v.x, this.v.y);
          ctx.strokeStyle = "blue";
          ctx.stroke();

          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(this.v.x, 0);
          ctx.strokeStyle = "red";
          ctx.stroke();

          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(0, this.v.y);
          ctx.strokeStyle = "green";
          ctx.stroke();

          ctx.restore();
        }
      }

      // init, update, draw

      let ball;

      let controls = {
        vx: 0,
        vy: 0,
        ay: 0.6,
        fade: 0.99,
        update: true,
        color: "#fff",
        step: function () {
          ball.update();
        },
        FPS: 30,
      };

      let gui = new dat.GUI();
      gui
        .add(controls, "vx", -50, 50)
        .listen()
        .onChange(function (val) {
          ball.v.x = val;
        });
      gui
        .add(controls, "vy", -50, 50)
        .listen()
        .onChange(function (val) {
          ball.v.y = val;
        });
      gui
        .add(controls, "ay", -1, 1)
        .step(0.001)
        .listen()
        .onChange(function (val) {
          ball.a.y = val;
        });
      gui.add(controls, "fade", -1, 1).step(0.01).listen();

      gui.add(controls, "update");
      gui.addColor(controls, "color");
      gui.add(controls, "step");
      gui.add(controls, "FPS", 1, 120);

      function init() {
        ball = new Ball();
      }
      init();

      function update() {
        if (controls.update) {
          ball.update();
        }
      }

      let timer = setInterval(update, 1000 / 30);

      function draw() {
        ctx.fillStyle = "rgba(0,0,0,0.5)";
        ctx.fillRect(0, 0, ww, wh);

        ball.draw();

        setTimeout(draw, 1000 / controls.FPS);
      }
      draw();

      function getDistance(p1, p2) {
        let temp1 = p1.x - p2.x;
        let temp2 = p1.y - p2.y;
        let dist = temp1 ** 2 + temp2 ** 2;
        return Math.sqrt(dist);
      }

      let mousePos = { x: 0, y: 0 };
      canvas.addEventListener("mousedown", function (evt) {
        mousePos = new Vector(evt.x, evt.y);
        let dist = mousePos.sub(ball.p).length();
        if (dist < ball.r) {
          ball.dragging = true;
        }
      });

      canvas.addEventListener("mousemove", function (evt) {
        let nowPos = new Vector(evt.x, evt.y);
        if (ball.dragging) {
          let delta = nowPos.sub(mousePos);
          ball.p = ball.p.add(delta);
          ball.v = delta.clone();
        }
        let dist = getDistance(nowPos, ball.p);
        if (dist < ball.r) {
          canvas.style.cursor = "pointer";
        } else {
          canvas.style.cursor = "initial";
        }

        mousePos = nowPos;
      });

      canvas.addEventListener("mouseup", function (evt) {
        ball.dragging = false;
      });
    </script>
  </body>
</html>
